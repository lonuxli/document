# 并发同步之每CPU变量

## 每CPU变量

    最好的同步技术是把设计不需要同步的临界资源放在首位，这是一种思维方法，因为每一种显式的同步原语都有不容忽视的性能开销。最简单也是最重要的同步技术包括把内核变量或数据结构声明为每CPU变量（per\-cpu variable）。每CPU变量主要是数据结构的数组，系统的每个CPU对应数组的一个元素。

    多核情况下，CPU是同时并发运行的，但是它们共同使用其他的硬件资源，因此我们需要解决多个CPU之间的同步问题。每CPU变量（per\-cpu\-variable）是内核中一种重要的同步机制。顾名思义，每CPU变量就是为每个CPU构造一个变量的副本，这样多个CPU相互操作各自的副本，互不干涉。比如我们标识当前进程的变量current\_task就被声明为每CPU变量。

    一个CPU不应该访问与其他CPU对应的数组元素，另外，它可以随意读或修改它自己的元素而不用担心出现竞争条件，因为它是唯一有资格这么做的CPU。但是，这也意味着每CPU变量基本上只能在特殊情况下使用，也就是当它确定在系统的CPU上的数据在逻辑上是独立的时候。

    **每CPU变量的特点：**

    1、用于多个CPU之间的同步，如果是单核结构，每CPU变量没有任何用处。

    2、每CPU变量不能用于多个CPU相互协作的场景（每个CPU的副本都是独立的）。

    3、每CPU变量不能解决由中断或延迟函数导致的同步问题。

**   4、****访问每CPU变量的时候，一定要确保关闭内核抢占，否则一个进程被抢占后可能会更换CPU运行****，这会导致每CPU变量的引用错误。**

    我们可以用数组来实现每CPU变量吗？比如，我们要保护变量var，我们可以声明int var\[NR\_CPUS\]，CPU num就访问var\[num\]不就可以了吗？

    显然，每CPU变量的实现不会这么简单。理由：我们知道为了加快内存访问，处理器中设计了硬件高速缓存（也就是CPU的cache），每个处理器都会有一个硬件高速缓存。如果每CPU变量用数组来实现，那么任何一个CPU修改了其中的内容，都会导致其他CPU的高速缓存中对应的块失效，而频繁的失效会导致性能急剧的下降。因此，每CPU的数组元素在主存中被排列以使每个数据结构存放在硬件高速缓存的不同行，这样，对每CPU数组的并发访问不会导致高速缓存行的窃用和失效（这种操作会带来昂贵的系统开销）。

    虽然每CPU变量为来自不同CPU的并发访问提供保护，但对来自异步函数（中断处理程序和可延迟函数）的访问不提供保护，在这种情况下需要另外的同步技术。

    每CPU变量分为静态和动态两种，静态的每CPU变量使用DEFINE\_PER\_CPU声明，在编译的时候分配空间；而动态的使用alloc\_percpu和free\_percpu来分配回收存储空间。

    **每CPU变量的函数和宏：**

    每CPU变量的定义在include\\linux\\percpu.h以及include\\asm\-generic\\percpu.h中。这些文件中定义了单核和多核情况下的每CPU变量的操作，这是为了代码的统一设计的，实际上只有在多核情况下\(定义了CONFIG\_SMP\)每CPU变量才有意义。

    常见的操作和含义如下：

|**函数名**                                   |**说明**                                                                                           |
|---------------------------------------------|---------------------------------------------------------------------------------------------------|
|DECLARE\_PER\_CPU\(type, name\)              |声明每CPU变量name，类型为type                                                                      |
|DEFINE\_PER\_CPU\(type, name\)               |静态分配一个每CPU数组，数组名为name，类型为type                                                    |
|alloc\_percpu\(type\)                        |动态为type类型的每CPU变量分配空间，并返回它的地址                                                  |
|free\_percpu\(pointer\)                      |释放为动态分配的每CPU变量的空间，pointer是起始地址                                                 |
|per\_cpu\(name, cpu\)                        |获取编号cpu的处理器上面的变量name的副本                                                            |
|get\_cpu\_var\(name\)                        |获取本处理器上面的变量name的副本，该函数禁用内核抢占，主要由\_\_get\_cpu\_var来完成具体的访问      |
|get\_cpu\_ptr\(name\)                        |获取本处理器上面的变量name的副本的指针，该函数禁用内核抢占，主要由\_\_get\_cpu\_var来完成具体的访问|
|put\_cpu\_var\(name\) & put\_cpu\_ptr\(name\)|表示每CPU变量的访问结束，启用内核抢占（不使用name）                                                |
|\_\_get\_cpu\_var\(name\)                    |获取本处理器上面的变量name的副本，该函数不禁用内核抢占                                             |

备注：

（1）cpu A可以通过接口per\_cpu\(name, cpu\)等获取到cpu B上的每CPU变量，进而进行访问修改，这种场景下的同步问题如何保证？

（2）以上场景下的每CPU使用，与前面所描述“一个CPU不应该访问与其他CPU对应的数组元素”所矛盾，这个如何正确理解？
