# å®‰å…¨ç®¡ç†ä¹‹æƒé™å˜åŒ–ä¸ç»§æ‰¿

`capability` `uid` `gid`

**ä¸€ã€æƒé™æœºåˆ¶**

æœ¬æ–‡ä¸»è¦å…³æ³¨å†…æ ¸ä¸­IDæƒé™æœºåˆ¶å’Œcapabilityæƒé™æœºåˆ¶ï¼Œå‚è€ƒå†…æ ¸ä¸º4.9

**1.1 idæœºåˆ¶**

**uid/gidÂ** 

real user ID å’Œ real group ID

**euid/egid**

effective user ID å’Œ effective group IDã€‚çœŸæ­£å»æ£€æŸ¥ä¸€ä¸ªè¿›ç¨‹æ˜¯å¦æœ‰æƒé™è¿›è¡ŒæŸäº›åŠ¨ä½œï¼Œä½¿ç”¨æ­¤æƒé™ã€‚

**suid/sgid**

saved set\-user\-ID å’Œ saved set\-group\-IDã€‚ä¸€ä¸ªè¿›ç¨‹åº”è¯¥ä»¥å°½å¯èƒ½å°çš„æƒé™è¿è¡Œã€‚å½“ä¸éœ€è¦euid/egidæƒé™è¿è¡Œçš„æ—¶å€™ï¼Œå¯ä»¥å°†euid/egidä¿å­˜åˆ°suid/sgidï¼Œç„¶åå°†euid/egidè®¾ç½®æˆuid/gidï¼Œä»¥è¾ƒå°çš„æƒé™è¿è¡Œã€‚

**fsuid/fsgid**

file\-system user ID å’Œ file\-system group ID

**1.2 capabilityæœºåˆ¶**

Linux capabilities åˆ†ä¸ºè¿›ç¨‹ capabilities å’Œæ–‡ä»¶ capabilitiesã€‚å¯¹äºè¿›ç¨‹æ¥è¯´ï¼Œcapabilities æ˜¯ç»†åˆ†åˆ°çº¿ç¨‹çš„ï¼Œå³æ¯ä¸ªçº¿ç¨‹å¯ä»¥æœ‰è‡ªå·±çš„capabilitiesã€‚å¯¹äºæ–‡ä»¶æ¥è¯´ï¼Œcapabilities ä¿å­˜åœ¨æ–‡ä»¶çš„æ‰©å±•å±æ€§ä¸­ã€‚

**Permitted**

å®šä¹‰äº†çº¿ç¨‹èƒ½å¤Ÿä½¿ç”¨çš„ capabilities çš„ä¸Šé™ã€‚å®ƒå¹¶ä¸ä½¿èƒ½çº¿ç¨‹çš„ capabilitiesï¼Œè€Œæ˜¯ä½œä¸ºä¸€ä¸ªè§„å®šã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œçº¿ç¨‹å¯ä»¥é€šè¿‡ç³»ç»Ÿè°ƒç”¨ capset\(\) æ¥ä» Effective æˆ– Inheritable é›†åˆä¸­æ·»åŠ æˆ–åˆ é™¤ capabilityï¼Œå‰ææ˜¯æ·»åŠ æˆ–åˆ é™¤çš„ capability å¿…é¡»åŒ…å«åœ¨ Permitted é›†åˆä¸­ï¼ˆå…¶ä¸­ Bounding é›†åˆä¹Ÿä¼šæœ‰å½±å“ï¼Œå…·ä½“å‚è€ƒä¸‹æ–‡ï¼‰ã€‚

**Effective**

å†…æ ¸æ£€æŸ¥çº¿ç¨‹æ˜¯å¦å¯ä»¥è¿›è¡Œç‰¹æƒæ“ä½œæ—¶ï¼Œæ£€æŸ¥çš„å¯¹è±¡ä¾¿æ˜¯ Effective é›†åˆã€‚å¦‚ä¹‹å‰æ‰€è¯´ï¼ŒPermitted é›†åˆå®šä¹‰äº†ä¸Šé™ï¼Œçº¿ç¨‹å¯ä»¥åˆ é™¤ Effective é›†åˆä¸­çš„æŸ capabilityï¼Œéšååœ¨éœ€è¦æ—¶ï¼Œå†ä» Permitted é›†åˆä¸­æ¢å¤è¯¥ capabilityï¼Œä»¥æ­¤è¾¾åˆ°ä¸´æ—¶ç¦ç”¨ capability çš„åŠŸèƒ½ã€‚

**Inheritable**

å½“æ‰§è¡Œexec\(\) ç³»ç»Ÿè°ƒç”¨æ—¶ï¼Œèƒ½å¤Ÿè¢«æ–°çš„å¯æ‰§è¡Œæ–‡ä»¶ç»§æ‰¿çš„ capabilitiesï¼Œè¢«åŒ…å«åœ¨ Inheritable é›†åˆä¸­ã€‚

**Bounding**

Bounding é›†åˆæ˜¯ Inheritable é›†åˆçš„è¶…é›†ï¼Œå¦‚æœæŸä¸ª capability ä¸åœ¨ Bounding é›†åˆä¸­ï¼Œå³ä½¿å®ƒåœ¨ Permitted é›†åˆä¸­ï¼Œè¯¥çº¿ç¨‹ä¹Ÿä¸èƒ½å°†è¯¥ capability æ·»åŠ åˆ°å®ƒçš„ Inheritable é›†åˆä¸­ã€‚

ä¸€æ—¦æŸä¸ª capability è¢«ä» Bounding é›†åˆä¸­åˆ é™¤ï¼Œä¾¿ä¸èƒ½å†æ·»åŠ å›æ¥ã€‚

**Ambient**

Linux 4.3 å†…æ ¸æ–°å¢äº†ä¸€ä¸ª capabilities é›†åˆå« Ambient ï¼Œç”¨æ¥å¼¥è¡¥ Inheritable çš„ä¸è¶³ã€‚

**äºŒã€è¿›ç¨‹çš„æƒé™å˜åŒ–è¿‡ç¨‹**

**2.1Â è¿›ç¨‹åˆ›å»ºæ—¶æƒé™å˜åŒ–**

è¿›ç¨‹åˆ›å»ºæ—¶ç»è¿‡do\_fork\(\)\-\>copy\_process\(\)ï¼Œæƒé™çš„å˜åŒ–å¯ä»¥è·Ÿè¸ªtask\_struct\-\>cred/åŠtask\_struct\-\>real\_credçš„å˜åŒ–

dup\_task\_struct\(\)æ—¶ï¼Œä¼šå°†çˆ¶task\_structæ‹·è´åˆ°å­task\_structï¼Œå› æ­¤æ­¤æ—¶task\_struct\-\>credæ¥è‡ªäºçˆ¶ã€‚

```
int copy_creds(struct task_struct *p, unsigned long clone_flags)
{
Â Â Â Â Â Â Â Â struct cred *new;
Â Â Â Â Â Â Â Â int ret;

Â Â  Â Â  Â  //å¦‚æœæ˜¯åˆ›å»ºçº¿ç¨‹ï¼Œæ–°çš„taskçš„real_credç­‰äºcred
Â Â Â Â Â Â Â Â if (clone_flags & CLONE_THREAD) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â p->real_cred = get_cred(p->cred);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â get_cred(p->cred);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â alter_cred_subscribers(p->cred, 2);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â kdebug("share_creds(%p{%d,%d})",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â p->cred, atomic_read(&p->cred->usage),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â read_cred_subscribers(p->cred));
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â atomic_inc(&p->cred->user->processes);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return 0;
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â new = prepare_creds(); //kmallocå‡ºä¸€ä¸ªcreadï¼Œå¹¶ä»current->credå¤åˆ¶å†…å®¹
Â Â Â Â Â Â Â Â if (!new)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return -ENOMEM;

Â Â  Â Â Â  Â //å¦‚æœæ˜¯åˆ›å»ºæ–°çš„user namespaceï¼Œä¼šè¿›ä¸€æ­¥è®¾ç½®credå†…å®¹
Â Â Â Â Â Â Â Â if (clone_flags & CLONE_NEWUSER) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ret = create_user_ns(new);Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (ret < 0)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â goto error_put;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â atomic_inc(&new->user->processes);
Â Â  Â Â  Â  //æœ€ç»ˆè®¾ç½®æ–°å»ºtask_structçš„credï¼Œå¹¶ä¸”real_credç­‰äºcred
Â Â Â Â Â Â Â Â p->cred = p->real_cred = get_cred(new);
Â Â Â Â Â Â Â Â alter_cred_subscribers(new, 2);
Â Â Â Â Â Â Â Â validate_creds(new);
Â Â Â Â Â Â Â Â return 0;

error_put:
Â Â Â Â Â Â Â Â put_cred(new);
Â Â Â Â Â Â Â Â return ret;
}
```

å¦‚æœåˆ›å»ºæ–°çš„å‘½åç©ºé—´ï¼Œcapabilityæƒé™å˜å¤§ï¼Œä½†æ˜¯è¿™ä¸ªå®Œæ•´æƒé™å—é™äºæ­¤å‘½åç©ºé—´ã€‚

```
static void set_cred_user_ns(struct cred *cred, struct user_namespace *user_ns)
{
Â Â Â Â Â Â Â Â /* Start with the same capabilities as init but useless for doing
Â Â Â Â Â Â Â Â Â * anything as the capabilities are bound to the new user namespace.
Â Â Â Â Â Â Â Â Â */
Â Â Â Â Â Â Â Â cred->securebits = SECUREBITS_DEFAULT;
Â Â Â Â Â Â Â Â cred->cap_inheritable = CAP_EMPTY_SET;
Â Â Â Â Â Â Â Â cred->cap_permitted = CAP_FULL_SET;
Â Â Â Â Â Â Â Â cred->cap_effective = CAP_FULL_SET;
Â Â Â Â Â Â Â Â cred->cap_ambient = CAP_EMPTY_SET;
Â Â Â Â Â Â Â Â cred->cap_bset = CAP_FULL_SET;

Â Â Â Â Â Â Â Â /* tgcred will be cleared in our caller bc CLONE_THREAD won't be set */
Â Â Â Â Â Â Â Â cred->user_ns = user_ns;
}
```

forkæ—¶æƒé™æ€»ç»“

**1ã€å¦‚æœæ˜¯åˆ›å»ºçº¿ç¨‹**

æ–°çš„çº¿ç¨‹task\_struct\-\>cred/task\_struct\-\>real\_credæŒ‡å‘çš„credç­‰åŒäºåˆ›å»ºçº¿ç¨‹çš„task\_struct\-\>credï¼Œå¹¶ä¸”æ–°çº¿ç¨‹çš„id/capabilityç­‰äºåˆ›å»ºçº¿ç¨‹

**2ã€å¦‚æœæ˜¯åˆ›å»ºè¿›ç¨‹ï¼Œä½†æ˜¯æ— åˆ›å»ºæ–°çš„userÂ ns**

æ–°çš„è¿›ç¨‹ï¼ˆä¸»çº¿ç¨‹ï¼‰task\_struct\-\>cred/task\_struct\-\>real\_credæŒ‡å‘æ–°åˆ›å»ºçš„credï¼Œä½†æ˜¯å†…å®¹å€¼ç­‰äºåˆ›å»ºçº¿ç¨‹çš„task\_struct\-\>credï¼Œå¹¶ä¸”æ–°è¿›ç¨‹çš„id/capabilityç­‰äºåˆ›å»ºçº¿ç¨‹ã€‚idåœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ä¸ä¼šå˜åŒ–ï¼Œæƒé™å˜åŒ–å…¬å¼å¦‚ä¸‹ï¼ˆå®é™…æ²¡å˜ï¼‰ï¼š

```
P'(ambient) =Â P(ambient)
P'(permitted) =Â P(permitted)
P'(effective) = P(effective)
P'(inheritable) = P(inheritable)
P'(cap_bset) = P(cap_bset)
```

**3ã€****å¦‚æœæ˜¯åˆ›å»ºè¿›ç¨‹ï¼Œå¹¶ä¸”åˆ›å»ºæ–°çš„userÂ ns**

æ–°çš„è¿›ç¨‹ï¼ˆä¸»çº¿ç¨‹ï¼‰task\_struct\-\>cred/task\_struct\-\>real\_credæŒ‡å‘æ–°åˆ›å»ºçš„credï¼Œä½†æ˜¯å†…å®¹å€¼ä¸»è¦æ¥æºäºåˆ›å»ºçº¿ç¨‹çš„task\_struct\-\>credï¼Œå¹¶ä¸”æ–°è¿›ç¨‹çš„idç­‰äºåˆ›å»ºçº¿ç¨‹ï¼Œcapabilityç”±set\_cred\_user\_ns\(\)è®¾ç½®ã€‚idåœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ä¸ä¼šå˜åŒ–ï¼Œæƒé™å˜åŒ–å…¬å¼å¦‚ä¸‹ï¼š

```
P'(ambient) =Â CAP_EMPTY_SET
P'(permitted) =Â CAP_FULL_SET
P'(effective) =Â CAP_FULL_SET
P'(inheritable) =Â CAP_EMPTY_SET
P'(cap_bset) =Â CAP_FULL_SET
```

**2.2Â execæ–‡ä»¶æ‰§è¡Œæ—¶æƒé™å˜åŒ–**

**2.2.1Â execæƒé™å˜åŒ–æ­¥éª¤**

exec\(\)æ‰§è¡Œæ—¶ï¼Œä¼šåŠ è½½æ–°çš„å¦‚elfæ–‡ä»¶ä»£ç æ•°æ®ï¼Œå¹¶åˆ‡åˆ°æ–°çš„ä»£ç æ‰§è¡Œï¼ŒåŒæ—¶æ‰§è¡Œæƒé™uid/gidå’Œcapabilityå‡ä¼šå‘ç”Ÿå˜åŒ–ã€‚

å…¶ä»£ç è·¯å¾„ä¸ºï¼šdo\_execve\(\) \-\>do\_execveat\_common\(\)

```
static int do_execveat_common(int fd, struct filename *filename,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â struct user_arg_ptr argv,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â struct user_arg_ptr envp,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â int flags)
{
Â  Â  ...
Â Â  Â prepare_bprm_creds(bprm); //åˆ›å»ºcred
Â  Â  ...
Â Â  Â prepare_binprm(bprm); //è®¾ç½®cred
Â  Â  ...
Â Â  Â exec_binprm(bprm); //å®‰è£…cred
Â  Â  ...
}
```

**2.2.2 åˆ›å»ºcred**

åˆ›å»ºå‡†å¤‡credä»£ç å¦‚ä¸‹ï¼Œåˆ›å»ºæ—¶æ˜¯åˆ†é…ä¸€ä¸ªæ–°çš„credï¼Œå¹¶ä¸”å¤åˆ¶æ‰§è¡Œè¿›ç¨‹è€çš„å·²æœ‰çš„credå†…å®¹ï¼Œå¹¶å°†æ–°åˆ›å»ºçš„credä¿å­˜åˆ°bprm\-\>credä¸­ã€‚

```
int prepare_bprm_creds(struct linux_binprm *bprm)
{
Â Â Â Â Â Â Â Â if (mutex_lock_interruptible(&current->signal->cred_guard_mutex))
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return -ERESTARTNOINTR;

Â Â Â Â Â Â Â Â bprm->cred = prepare_exec_creds();
Â Â Â Â Â Â Â Â if (likely(bprm->cred))
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return 0;

Â Â Â Â Â Â Â Â mutex_unlock(&current->signal->cred_guard_mutex);
}

struct cred *prepare_exec_creds(void)
{
Â Â Â Â Â Â Â Â struct cred *new;

Â Â Â Â Â Â Â Â new = prepare_creds();Â //kmallocå‡ºä¸€ä¸ªcreadï¼Œå¹¶ä»current->credå¤åˆ¶å†…å®¹
Â Â Â Â Â Â Â Â return new;
}
```

**2.2.3 ä¿®æ”¹cred**

åœ¨execæ‰§è¡Œå¯æ‰§è¡Œæ–‡ä»¶çš„è¿‡ç¨‹ä¸­ï¼Œé¦–å…ˆä¼šåœ¨bprm\_fill\_uid\(\)å‡½æ•°ä¸­æ ¹æ®å½“å‰å¯æ‰§è¡Œæ–‡ä»¶modeä¸­ä¿å­˜S\_ISUID/S\_ISGIDæ ‡å¿—ï¼Œæ¥ä¿®æ­£execåè¿›ç¨‹çš„idæ˜¯å¦éœ€è¦ä¿®æ”¹ã€‚

```
static void bprm_fill_uid(struct linux_binprm *bprm)
{
Â Â Â Â Â Â Â Â struct inode *inode;
Â Â Â Â Â Â Â Â unsigned int mode;
Â Â Â Â Â Â Â Â kuid_t uid;
Â Â Â Â Â Â Â Â kgid_t gid;

Â Â Â Â Â Â Â Â /*
Â Â Â Â Â Â Â Â Â * Since this can be called multiple times (via prepare_binprm),
Â Â Â Â Â Â Â Â Â * we must clear any previous work done when setting set[ug]id
Â Â Â Â Â Â Â Â Â * bits from any earlier bprm->file uses (for example when run
Â Â Â Â Â Â Â Â Â * first for a setuid script then again for its interpreter).
Â Â Â Â Â Â Â Â Â */
Â Â  Â Â Â  Â //è¿™æ­¥çš„ä½œç”¨æ˜¯é˜²æ­¢å¤šæ¬¡è°ƒç”¨ï¼Œè€Œé‡æ–°åˆå§‹åŒ–cred->euidä¸ºè¿è¡Œexecè¿›ç¨‹çš„euidï¼Œæš‚æ—¶ä¸æ˜¯å¾ˆç†è§£è¿™ç§åœºæ™¯æƒ…å†µ
Â Â Â Â Â Â Â Â bprm->cred->euid = current_euid();Â Â 
Â Â Â Â Â Â Â Â bprm->cred->egid = current_egid();

Â Â  Â Â  Â  //æœ‰äº›æƒ…å†µä¸‹çš„mountsæ˜¯ä¸æ”¯æŒsetÂ u/gidçš„ï¼Œå› æ­¤ç›´æ¥é€€å‡º
Â Â Â Â Â Â Â Â if (!mnt_may_suid(bprm->file->f_path.mnt))
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return;

Â Â Â Â Â Â Â Â if (task_no_new_privs(current))
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return;

Â Â Â Â Â Â Â Â inode = file_inode(bprm->file);
Â Â Â Â Â Â Â Â mode = READ_ONCE(inode->i_mode);
Â Â Â Â Â Â Â Â if (!(mode & (S_ISUID|S_ISGID)))Â  //å¦‚æœå¯æ‰§è¡Œæ–‡ä»¶ç¡®å®æ²¡æœ‰è®¾ç½®setÂ u/gidï¼Œç›´æ¥é€€å‡º
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return;

Â Â Â Â Â Â Â Â /* Be careful if suid/sgid is set */
Â Â Â Â Â Â Â Â inode_lock(inode);

Â Â Â Â Â Â Â Â /* reload atomically mode/uid/gid now that lock held */
Â Â Â Â Â Â Â Â mode = inode->i_mode;
Â Â Â Â Â Â Â Â uid = inode->i_uid;
Â Â Â Â Â Â Â Â gid = inode->i_gid;
Â Â Â Â Â Â Â Â inode_unlock(inode);

Â Â Â Â Â Â Â Â /* We ignore suid/sgid if there are no mappings for them in the ns */
Â Â  Â Â  Â  //å¦‚æœæ–‡ä»¶çš„uid/gidåœ¨æ‰§è¡Œè¿›ç¨‹çš„userÂ ns,ä¹Ÿå³bprm->cred->user_nsä¸­ä¸å­˜åœ¨ï¼Œåˆ™å¿½ç•¥suid/sgidçš„ä½œç”¨
Â Â Â Â Â Â Â Â if (!kuid_has_mapping(bprm->cred->user_ns, uid) ||
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â !kgid_has_mapping(bprm->cred->user_ns, gid))
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â  Â Â Â  Â //å¦‚æœè®¾ç½®äº†S_ISUIDæ ‡å¿—ï¼Œåˆ™ä¿®æ”¹execåè¿›ç¨‹çš„euidä¸ºå¯æ‰§è¡Œæ–‡ä»¶çš„uid
Â Â Â Â Â Â Â Â if (mode & S_ISUID) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â bprm->per_clear |= PER_CLEAR_ON_SETID;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â bprm->cred->euid = uid;Â Â 
Â  Â  Â  Â  }

Â Â  Â Â  Â  //å¦‚æœè®¾ç½®äº†S_ISGIDå’ŒS_IXGRPï¼Œåˆ™ä¿®æ”¹execåè¿›ç¨‹çš„egidä¸ºå¯æ‰§è¡Œæ–‡ä»¶çš„gidï¼Œä¸ºä½•éœ€è¦åŒæ—¶è®¾ç½®äº†S_IXGRPæ ‡å¿—
Â Â Â Â Â Â Â Â if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â bprm->per_clear |= PER_CLEAR_ON_SETID;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â bprm->cred->egid = gid;
Â Â Â Â Â Â Â Â }
}
```

å…¶æ¬¡åœ¨execæ‰§è¡Œå¯æ‰§è¡Œæ–‡ä»¶çš„è¿‡ç¨‹ä¸­ï¼Œä¼šåœ¨å‡½æ•°cap\_bprm\_set\_creds\(\)åœ¨è®¡ç®—execåè¿›ç¨‹çš„

do\_execve\(\) \-\>do\_execveat\_common\(\)\-\>prepare\_binprm\(\)\-\> security\_bprm\_set\_creds\(\)\-\> cap\_bprm\_set\_creds\(\)

```
int cap_bprm_set_creds(struct linux_binprm *bprm)
{
Â Â Â Â Â Â Â Â const struct cred *old = current_cred();
Â Â Â Â Â Â Â Â struct cred *new = bprm->cred;
Â Â Â Â Â Â Â Â bool effective, has_cap = false, is_setid;
Â Â Â Â Â Â Â Â int ret;
Â Â Â Â Â Â Â Â kuid_t root_uid;

Â Â Â Â Â Â Â Â if (WARN_ON(!cap_ambient_invariant_ok(old)))
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return -EPERM;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â effective = false;
Â Â Â Â Â Â Â Â ret = get_file_caps(bprm, &effective, &has_cap);
Â Â Â Â Â Â Â Â if (ret < 0)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return ret;
Â Â  Â Â  Â  //è®¡ç®—å½“å‰å‘½åç©ºé—´ä¸‹uidä¸º0çš„å…¨å±€idå€¼
Â Â  Â Â Â  Â root_uid = make_kuid(new->user_ns, 0);

Â Â  Â Â  Â  //å¦‚æœæœªè®¾ç½®SECURE_NOROOTçŠ¶æ€ä½ï¼Œåˆ™é’ˆå¯¹rootç”¨æˆ·è¦ç‰¹æ®Šå¤„ç†å¹¶ææƒï¼Œå‰é¢è®¡ç®—å‡ºçš„new->cap_permittedå°±æ²¡ç”¨
Â Â Â Â Â Â Â Â if (!issecure(SECURE_NOROOT)) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (uid_eq(new->euid, root_uid) || uid_eq(new->uid, root_uid)) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â /* pP' = (cap_bset & ~0) | (pI & ~0) */
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â new->cap_permitted = cap_combine(old->cap_bset,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â old->cap_inheritable);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (uid_eq(new->euid, root_uid))
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â effective = true;
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â /* if we have fs caps, clear dangerous personality flags */
Â Â Â Â Â Â Â Â if (!cap_issubset(new->cap_permitted, old->cap_permitted))
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â bprm->per_clear |= PER_CLEAR_ON_SETID;

Â Â  Â Â  Â  //execåè¿›ç¨‹çš„idä¹Ÿä¼šå˜åŒ–
Â Â Â Â Â Â Â Â new->suid = new->fsuid = new->euid;
Â Â Â Â Â Â Â Â new->sgid = new->fsgid = new->egid;

Â Â Â Â Â Â Â Â /* File caps or setid cancels ambient. */
Â Â  Â Â  Â  //æ–‡ä»¶ä¸Šæ‰€å¸¦çš„F(VFS_CAP_REVISION_MASK) || F(set-user-id)è¿™ä¸¤ç§æ ‡å¿—ä¼šæ¸…é™¤ambient
Â Â Â Â Â Â Â Â if (has_cap || is_setid)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â cap_clear(new->cap_ambient);

Â Â  Â Â Â  Â is_setid = !uid_eq(new->euid, old->uid) || !gid_eq(new->egid, old->gid);

Â Â Â Â Â Â Â Â /*
Â Â Â Â Â Â Â Â Â * Now that we've computed pA', update pP' to give:
Â Â Â Â Â Â Â Â Â *Â Â Â pP' = (X & fP) | (pI & fI) | pA'
Â Â Â Â Â Â Â Â Â */
Â Â  Â Â  Â  //new->cap_permittedåœ¨bprm_caps_from_vfs_capsä¸­å·²ç»è®¾ç½®è¿‡ä¸€é
Â Â  Â Â  Â  //å› æ­¤å½“å‰P'(permitted) = (P(inheritable) & F(inheritable)) | (F(permitted) & cap_bset)
Â Â  Â Â Â  Â //æ•´ä½“ç»¼åˆæ˜¯è®¡ç®—ï¼šP'(permitted) = (P(inheritable) & F(inheritable)) | (F(permitted) & cap_bset) | P'(ambient)
Â Â Â Â Â Â Â Â new->cap_permitted = cap_combine(new->cap_permitted, new->cap_ambient);

Â Â Â Â Â Â Â Â /*
Â Â Â Â Â Â Â Â Â * Set pE' = (fE ? pP' : pA').Â Â Because pA' is zero if fE is set,
Â Â Â Â Â Â Â Â Â * this is the same as pE' = (fE ? pP' : 0) | pA'.
Â Â Â Â Â Â Â Â Â */
Â Â  Â Â  Â  //å› ä¸ºP'(permitted)ä¸­å·²ç»æˆ–ä¸ŠP'(ambient)ï¼Œå†æˆ–æ— ç”¨ï¼Œå› æ­¤pE' = (fE ? pP' : 0) | pA'å¯ä»¥ç®€åŒ–ä¸ºpE' = (fE ? pP' : pA')
Â Â  Â Â  Â  //è®¡ç®—P'(effective) = F(effective) ? P'(permitted) :Â P'(ambient)
Â Â Â Â Â Â Â Â if (effective)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â new->cap_effective = new->cap_permitted;
Â Â Â Â Â Â Â Â else
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â new->cap_effective = new->cap_ambient;

Â Â Â Â Â Â Â Â if (WARN_ON(!cap_ambient_invariant_ok(new)))
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return -EPERM;

Â Â Â Â Â Â Â Â bprm->cap_effective = effective;
}

//ä»å¯æ‰§è¡Œæ–‡ä»¶ä¸­è·å–é™„ä»¶æƒé™
static int get_file_caps(struct linux_binprm *bprm, bool *effective, bool *has_cap)
{
Â Â Â Â Â Â Â Â int rc = 0;
Â Â Â Â Â Â Â Â struct cpu_vfs_cap_data vcaps;

Â Â Â Â Â Â Â Â bprm_clear_caps(bprm);

Â Â  Â Â Â  Â //å…¨å±€å˜é‡æ ‡è®°file capæ˜¯å¦æ”¯æŒï¼Œå¦‚æœä¸æ”¯æŒåˆ™ç›´æ¥é€€å‡º
Â Â Â Â Â Â Â Â if (!file_caps_enabled)Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return 0;

Â Â  Â Â  Â  //é˜²æ­¢å­˜åœ¨å…¶ä»–ä¸å®‰å…¨userÂ nsä¸­suid/sgid bits, file caps, or security labels
Â Â  Â Â  Â  //åº”è¯¥å±äºuserÂ nså¯¹mountçš„éš”ç¦»æ£€æŸ¥ï¼Ÿ
Â Â  Â Â  Â  //æ£€æŸ¥ä¸é€šè¿‡åˆ™ç›´æ¥é€€å‡º
Â Â Â Â Â Â Â Â if (!mnt_may_suid(bprm->file->f_path.mnt))Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return 0;

Â Â  Â Â Â  Â Â Â  Â Â  Â  //æ£€æŸ¥å½“å‰è¿›ç¨‹çš„userÂ nsæ˜¯å¦ä¸ºs_user_nsçš„åä»£ï¼Œå¦‚æœä¸æ˜¯å…¶åä»£åˆ™ç›´æ¥è¿”å›
Â Â  Â Â  Â  //å½“å‰è¿›ç¨‹ä¸æ˜¯å¯æ‰§è¡Œæ–‡ä»¶userÂ nsåä»£å°±ç›´æ¥é€€å‡º
Â Â Â Â Â Â Â Â if (!current_in_userns(bprm->file->f_path.mnt->mnt_sb->s_user_ns))
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return 0;

Â Â  Â Â  Â  //è°ƒç”¨__vfs_getxattrè·å–fileÂ cap
Â Â Â Â Â Â Â Â rc = get_vfs_caps_from_disk(bprm->file->f_path.dentry, &vcaps);
Â Â Â Â Â Â Â Â if (rc < 0) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (rc == -EINVAL)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â printk(KERN_NOTICE "%s: get_vfs_caps_from_disk returned %d for %s\n",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â __func__, rc, bprm->filename);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â else if (rc == -ENODATA)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â rc = 0;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â goto out;
Â Â Â Â Â Â Â Â }

Â Â  Â Â  Â  //é€šè¿‡è·å–åˆ°çš„fileÂ capå…ˆåšä¸€æ­¥P'(permitted)çš„æƒé™è®¡ç®—ï¼Œ
Â Â Â Â Â Â Â Â rc = bprm_caps_from_vfs_caps(&vcaps, bprm, effective, has_cap);
Â Â Â Â Â Â Â Â if (rc == -EINVAL)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â printk(KERN_NOTICE "%s: cap_from_disk returned %d for %s\n",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â __func__, rc, bprm->filename);

out:
Â Â Â Â Â Â Â Â if (rc)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â bprm_clear_caps(bprm);

Â Â Â Â Â Â Â Â return rc;
}

static inline int bprm_caps_from_vfs_caps(struct cpu_vfs_cap_data *caps,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â struct linux_binprm *bprm,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â bool *effective,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â bool *has_cap)
{
Â Â Â Â Â Â Â Â struct cred *new = bprm->cred;
Â Â Â Â Â Â Â Â unsigned i;
Â Â Â Â Â Â Â Â int ret = 0;

Â Â  Â Â  Â  //åˆ¤æ–­å¯æ‰§è¡Œæ–‡ä»¶æ˜¯å¦å¸¦æœ‰F(effective)æ ‡å¿—
Â Â Â Â Â Â Â Â if (caps->magic_etc & VFS_CAP_FLAGS_EFFECTIVE)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â *effective = true;

Â Â Â Â Â Â Â Â if (caps->magic_etc & VFS_CAP_REVISION_MASK)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â *has_cap = true;

Â Â Â Â Â Â Â Â CAP_FOR_EACH_U32(i) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â __u32 permitted = caps->permitted.cap[i];
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â __u32 inheritable = caps->inheritable.cap[i];

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â /*
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â * pP' = (X & fP) | (pI & fI)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â * The addition of pA' is handled later.
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â */

Â Â  Â Â Â  Â Â Â  Â Â  Â  //è®¡ç®—P'(permitted) = (P(inheritable) & F(inheritable)) | (F(permitted) & cap_bset)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â new->cap_permitted.cap[i] =
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â (new->cap_bset.cap[i] & permitted) |
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â (new->cap_inheritable.cap[i] & inheritable);

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (permitted & ~new->cap_permitted.cap[i])
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â /* insufficient to execute correctly */
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ret = -EPERM;
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â /*
Â Â Â Â Â Â Â Â Â * For legacy apps, with no internal support for recognizing they
Â Â Â Â Â Â Â Â Â * do not have enough capabilities, we return an error if they are
Â Â Â Â Â Â Â Â Â * missing some "forced" (aka file-permitted) capabilities.
Â Â Â Â Â Â Â Â Â */
Â Â Â Â Â Â Â Â return *effective ? ret : 0;
}
```

**æ ¹æ®ä»¥ä¸Šä»£ç ä»¥åŠä¹¦ç±39ç«** 

**ä»¥ä¸Šexecè¿‡ç¨‹ä¸­capabilityæƒé™å˜åŒ–å½’çº³ä¸ºï¼š**

ï¼ˆ1ï¼‰ å¦‚æœexecåçš„è¿›ç¨‹uid/euidä¸ºérootç”¨æˆ·æˆ–è€…åœ¨æœªè®¾ç½® SECURE\_NOROOTçŠ¶æ€æœªçš„æƒ…å†µä¸‹ï¼Œexecåè¿›ç¨‹æƒé™è®¡ç®—ä¸ºï¼š

```
P'(ambient) = (F(VFS_CAP_REVISION_MASK) ||Â F(set-user-id)) ? 0 :Â P(ambient) //P'(ambient)ä¸å¯æ‰§è¡Œæ–‡ä»¶æœ‰å…³
P'(permitted) = P(inheritable) & F(inheritable)) | (F(permitted) & P(cap_bset) | P'(ambient)
P'(effective) = F(effectiveÂ flag) ? P'(permitted) :Â P'(ambient)
P'(inheritable) = P(inheritable)
P'(cap_bset) =Â P(cap_bset)
```

ï¼ˆ2ï¼‰ä¸ºäº†ä¿ç•™ä»¥å‰å¯¹rootç”¨æˆ·èµ‹äºˆç‰¹æƒè¿™ä¹ˆä¸€ä¸ªæœºåˆ¶ï¼ˆå‚è€ƒ39.5.2ä¸€èŠ‚ï¼‰ï¼Œå¦‚æœexecåçš„è¿›ç¨‹uid/euidä¸ºrootç”¨æˆ·å¹¶ä¸”åœ¨æœªè®¾ç½® SECURE\_NOROOTçŠ¶æ€æœªçš„æƒ…å†µä¸‹ï¼Œå¯¹execåè¿›ç¨‹çš„æƒé™è®¡ç®—å¦‚ä¸‹ï¼Œåœ¨è¯¥è®¡ç®—æ–¹æ³•ä¸­å°†å®Œå…¨å¿½ç•¥æ‰æ–‡ä»¶æ‰€é™„å¸¦çš„æƒé™fileÂ capabilityï¼š

```
P'(ambient) = (F(VFS_CAP_REVISION_MASK) || F(set-user-id)) ? 0 : P(ambient)
P'(permitted) = P(inheritable) |Â P(cap_bset)Â |Â P'(ambient)
P'(effective) = P'(permitted)
P'(inheritable) = P(inheritable)
P'(cap_bset) = P(cap_bset)
```

\(3\)Â ä»¥ä¸Šæƒé™è®¡å‰åï¼Œè¿˜è¦ä¿è¯

```
P(ambient)Â Â Â Â <<Â Â Â P(permitted) & P(inheritable)Â  Â //æƒé™è®¡ç®—å‰ï¼Œå‰è€…æ˜¯åè€…çš„å­é›†ï¼Œä¸èƒ½è¶…å‡ºåè€…
P'(ambient)Â  Â  <<Â  Â P'(permitted) &Â P'(inheritable) //æƒé™è®¡ç®—åï¼Œå‰è€…æ˜¯åè€…çš„å­é›†ï¼Œä¸èƒ½è¶…å‡ºåè€…
```

**ä»¥ä¸Šexecè¿‡ç¨‹ä¸­idå˜åŒ–æ€»ç»“ä¸ºï¼š**

ï¼ˆ1ï¼‰å¯æ‰§è¡Œæ–‡ä»¶ä¸å­˜åœ¨setÂ u/gidæ ‡å¿—ï¼šè¿›ç¨‹æ‰§è¡Œexecå‰åcredä¸idç›¸å…³çš„å€¼ä¿æŒä¸å˜ã€‚

```
P'(uid) = P(uid)
P'(euid) = P(euid)
P'(suid) = P(euid)
P'(fsuid) = P(euid)

P'(gid) = P(gid)
P'(egid) = P(egid)
P'(sgid) = P(egid)
P'(fsgid) = P(egid)
```

ï¼ˆ2ï¼‰å¯æ‰§è¡Œæ–‡ä»¶å­˜åœ¨setÂ u/gidæ ‡å¿—ï¼šè¿›ç¨‹æ‰§è¡Œexecåï¼Œcred\-\>euid/egidä¼šå˜æˆæ–‡ä»¶çš„u/gidï¼Œè¿›ç¨‹çš„u/gidä¸ä¼šå‘ç”Ÿå˜åŒ–ï¼Œå…¶ä»–idä¼šåœ¨cap\_bprm\_set\_creds\(\)ä¿®æ”¹ã€‚

```
P'(uid) = P(uid)
P'(euid) =Â F(uid)
P'(suid) =Â F(uid)Â æˆ–Â P'(euid)
P'(fsuid) =Â F(euid) æˆ–Â P'(euid)

P'(gid) = P(gid)
P'(egid) = F(S_ISGID & S_IXGRPP) ï¼ŸF(uid) :Â P(gid)
P'(sgid) =Â P'(egid)
P'(fsgid) =Â P'(egid)
```

**2.2.4 æäº¤cred**

exec\(\)æ‰§è¡Œæ—¶ï¼Œåœ¨åŠ è½½æ–°çš„å¯æ‰§è¡Œæ–‡ä»¶ä»£ç åï¼Œè®¡ç®—å®Œæˆæƒé™ä»¥åŠidå˜æ›´ä¹‹åï¼Œæœ€åéœ€è¦ä¿®æ”¹å½“å‰currentè¿›ç¨‹çš„credï¼Œä»¥è¾¾åˆ°æœ€ç»ˆæäº¤ç”Ÿæ•ˆï¼Œè·¯å¾„å¦‚ä¸‹ï¼š

exec\_binprm\(\)\-\>search\_binary\_handler\(\)\-\>load\_elf\_binary\(\)\-\>install\_exec\_creds\(bprm\);\-\>commit\_creds\(bprm\-\>cred\);

**2.3Â ä¸»åŠ¨ä¿®æ—¶æ”¹æƒé™å˜åŒ–**

**2.3.1 ä¿®æ”¹idæ—¶æƒé™å˜åŒ–**

åœ¨ä¸è€ƒè™‘securebitsè®¾ç½®ä¸å¦çš„å½±å“ä¸‹ï¼Œå³ä¸‹é¢ä»£ç åˆ é™¤æ‰ç›¸å…³bitä½çš„åˆ¤æ–­é€»è¾‘ï¼Œè®¤ä¸ºä¸ºè®¾ç½® securebitsã€‚

setuid\(\)ç³»ç»Ÿè°ƒç”¨ä¸€æ–¹é¢ä¼šè§†æƒ…å†µä¿®æ”¹suid/uid/fsuid/euidï¼Œå¦ä¸€æ–¹é¢å¦‚æœå‘ç”Ÿäº†ä¸rootç›¸å…³çš„idå˜åŒ–ï¼Œéœ€è¦ä¿®æ­£capabilityã€‚

```
SYSCALL_DEFINE1(setuid, uid_t, uid)
{
Â Â Â Â Â Â Â Â struct user_namespace *ns = current_user_ns();
Â Â Â Â Â Â Â Â const struct cred *old;
Â Â Â Â Â Â Â Â struct cred *new;
Â Â Â Â Â Â Â Â int retval;
Â Â Â Â Â Â Â Â kuid_t kuid;

Â Â Â Â Â Â Â Â kuid = make_kuid(ns, uid);
Â Â Â Â Â Â Â Â new = prepare_creds();
Â Â Â Â Â Â Â Â if (!new)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return -ENOMEM;
Â Â Â Â Â Â Â Â old = current_cred();

Â Â Â Â Â Â Â Â retval = -EPERM;
Â Â  Â Â  Â  //è¦ä¹ˆè¿›ç¨‹å…¶cap_effectiveå…·å¤‡CAP_SETUIDæƒé™ï¼Œè¦ä¹ˆæ–°çš„uidç­‰äºæ—§çš„uid/suidæ‰èƒ½è¢«è®¾ç½®
Â Â Â Â Â Â Â Â if (ns_capable(old->user_ns, CAP_SETUID)) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â new->suid = new->uid = kuid;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (!uid_eq(kuid, old->uid)) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â retval = set_user(new);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (retval < 0)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â goto error;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â } else if (!uid_eq(kuid, old->uid) && !uid_eq(kuid, new->suid)) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â goto error;
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â new->fsuid = new->euid = kuid;
Â Â  Â Â  Â  //é€šè¿‡LSMæœºåˆ¶è°ƒç”¨cap_task_fix_setuidä¿®æ­£setuid()è¿‡ç¨‹ä¸­capability
Â Â Â Â Â Â Â Â retval = security_task_fix_setuid(new, old, LSM_SETID_ID);
Â Â Â Â Â Â Â Â if (retval < 0)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â goto error;

Â Â Â Â Â Â Â Â return commit_creds(new);

error:
Â Â Â Â Â Â Â Â abort_creds(new);
Â Â Â Â Â Â Â Â return retval;
}

static inline void cap_emulate_setxuid(struct cred *new, const struct cred *old)
{
Â Â Â Â Â Â Â Â kuid_t root_uid = make_kuid(old->user_ns, 0);

Â Â Â Â Â Â Â Â if ((uid_eq(old->uid, root_uid) ||
Â Â Â Â Â Â Â Â Â Â Â Â Â uid_eq(old->euid, root_uid) ||
Â Â Â Â Â Â Â Â Â Â Â Â Â uid_eq(old->suid, root_uid)) &&
Â Â Â Â Â Â Â Â Â Â Â Â (!uid_eq(new->uid, root_uid) &&
Â Â Â Â Â Â Â Â Â Â Â Â Â !uid_eq(new->euid, root_uid) &&
Â Â Â Â Â Â Â Â Â Â Â Â Â !uid_eq(new->suid, root_uid))) {
Â Â  Â Â Â  Â Â  Â  //å½“uid/euid/suidä»æœ‰rootå˜æˆå®Œå…¨érootï¼Œæ¸…ç©ºä»¥ä¸‹æƒé™ä½ã€‚
Â  Â  Â  Â  Â  Â  Â  Â  Â cap_clear(new->cap_permitted);
Â  Â  Â  Â  Â  Â  Â  Â  Â cap_clear(new->cap_effective);
Â  Â  Â  Â  Â  Â  Â  Â  Â cap_clear(new->cap_ambient);
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â if (uid_eq(old->euid, root_uid) && !uid_eq(new->euid, root_uid))
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â cap_clear(new->cap_effective); //euidä»rootå˜æˆéroot
Â Â Â Â Â Â Â Â if (!uid_eq(old->euid, root_uid) && uid_eq(new->euid, root_uid))
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â new->cap_effective = new->cap_permitted; //euidä»érootå˜æˆroot
}
```

**è¿›ç¨‹æˆåªæœ‰åœ¨ä»¥ä¸‹ä¸¤ç§æƒ…å†µä¸‹é€šè¿‡setuid\(\)ä¿®æ”¹è‡ªèº«çš„id**

1ã€åœ¨è¿›ç¨‹æ‰€æŒ‡çš„userÂ nsä¸­å…¶cap\_effectiveå…·å¤‡CAP\_SETUIDæƒé™æ—¶ï¼Œsuid/uid/fsuid/euidå‡ä¼šè¢«è®¾ç½®æˆæ–°çš„uid

2ã€è¿›ç¨‹åŸå…ˆè€çš„uid/suidä¸­å­˜åœ¨ç­‰äºæ–°çš„uidæ—¶ï¼Œfsuid/euidå¯ä»¥è¢«è®¾ç½®æˆæ–°çš„uidã€‚

**è¿›ç¨‹åœ¨é€šè¿‡setuid\(\)æ”¹å˜è‡ªèº«idæ—¶ï¼Œåªæœ‰åœ¨rootå’Œérooté—´åˆ‡æ¢æ—¶ï¼Œæ‰ä¼šéœ€è¦ä¿®æ­£capability**

1ã€åŒ…æ‹¬euidåœ¨å†…çš„idç”±rootå˜æˆå…¨éroot

```
P'(ambient) = CAP_EMPTY_SET
P'(permitted) = CAP_EMPTY_SET
P'(effective) = CAP_EMPTY_SET
P'(inheritable) =Â P(inheritable)
P'(cap_bset) =Â P(cap_bset)
```

2ã€euidç”±rootå˜æˆérootï¼Œå…¶ä»–uid/suidè¿˜æœ‰root

```
P'(ambient) =Â P(ambient)
P'(permitted) =Â P(permitted)
P'(effective) = CAP_EMPTY_SET
P'(inheritable) = P(inheritable)
P'(cap_bset) = P(cap_bset)
```

3ã€euidç”±érootå˜æˆroot

```
P'(ambient) = P(ambient)
P'(permitted) = P(permitted)
P'(effective) =Â P(permitted)
P'(inheritable) = P(inheritable)
P'(cap_bset) = P(cap_bset)
```

_å…¶ä»–çš„idä¿®æ”¹ç³»ç»Ÿè°ƒç”¨setreuid/setresuid/getresuid/setfsuidç›¸å…³åŸç†ä¸ä¸Šé¢å·®ä¸å¤šï¼Œå…·ä½“çš„ç»†èŠ‚å¯ä»¥æŸ¥çœ‹ä»£ç ã€‚_

**2.3.2 ä¿®æ”¹capabilityæ—¶æƒé™å˜åŒ–**

capset\(\)æ”¯æŒè¿›ç¨‹è®¾ç½®\_\_user\_cap\_data\_structæ‰€è¡¨ç¤ºçš„ä¸‰ç§æƒé™ï¼Œä»ä»£ç å®ç°å¯ä»¥çœ‹å‡ºï¼Œè¯¥å‡½æ•°åªèƒ½å®ç°é™æƒï¼Œè€Œæ— æ³•ææƒã€‚

```
typedef struct __user_cap_data_struct {
Â Â Â Â Â Â Â Â __u32 effective;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â __u32 permitted;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â __u32 inheritable;
} __user *cap_user_data_t;

SYSCALL_DEFINE2(capset, cap_user_header_t, header, const cap_user_data_t, data)
{
Â Â  Â Â  Â  ...
Â Â  Â Â Â  Â cap_validate_magic(header, &tocopy);
Â Â Â Â Â Â Â Â if (copy_from_user(&kdata, data, copybytes))
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return -EFAULT;

Â Â Â Â Â Â Â Â for (i = 0; i < tocopy; i++) {
Â Â  Â Â Â  Â Â Â  Â Â  Â  //è½¬æ¢ç”¨æˆ·æ€è®¾ç½®çš„cap
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â effective.cap[i] = kdata[i].effective;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â permitted.cap[i] = kdata[i].permitted;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â inheritable.cap[i] = kdata[i].inheritable;
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â new = prepare_creds();
Â Â Â Â Â Â Â Â if (!new)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return -ENOMEM;
Â Â  Â Â  Â  //é€šè¿‡LSMæœºåˆ¶è°ƒç”¨æ¥å£è¿›è¡Œcapè®¾ç½®
Â Â Â Â Â Â Â Â ret = security_capset(new, current_cred(), &effective, &inheritable, &permitted);
Â Â Â Â Â Â Â Â if (ret < 0)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â goto error;

Â Â Â Â Â Â Â Â audit_log_capset(new, current_cred());

Â Â Â Â Â Â Â Â return commit_creds(new);
}

LSM_HOOK_INIT(capset, selinux_capset)Â  //æƒé™æ ¡éªŒï¼Œå…ˆä¸è€ƒè™‘
LSM_HOOK_INIT(capset, cap_capset)

int cap_capset(struct cred *new,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const struct cred *old,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const kernel_cap_t *effective,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const kernel_cap_t *inheritable,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const kernel_cap_t *permitted)
{
Â Â  Â Â  Â  //cap_inh_is_capped()è®¡ç®—è¿›ç¨‹åœ¨å…¶userÂ nsä¸­æ˜¯å¦å…·å¤‡CAP_SETPCAPæƒé™
Â Â Â Â Â Â Â Â if (cap_inh_is_capped() &&Â 
Â Â Â Â Â Â Â Â Â Â Â Â !cap_issubset(*inheritable,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â cap_combine(old->cap_inheritable,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â old->cap_permitted)))
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â /* incapable of using this inheritable set */
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return -EPERM;

Â Â Â Â Â Â Â Â if (!cap_issubset(*inheritable,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â cap_combine(old->cap_inheritable,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â old->cap_bset)))
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â /* no new pI capabilities outside bounding set */
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return -EPERM;

Â Â Â Â Â Â Â Â /* verify restrictions on target's new Permitted set */
Â Â Â Â Â Â Â Â if (!cap_issubset(*permitted, old->cap_permitted))
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return -EPERM;

Â Â Â Â Â Â Â Â /* verify the _new_Effective_ is a subset of the _new_Permitted_ */
Â Â Â Â Â Â Â Â if (!cap_issubset(*effective, *permitted))
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return -EPERM;

Â Â Â Â Â Â Â Â new->cap_effectiveÂ Â Â = *effective;
Â Â Â Â Â Â Â Â new->cap_inheritable = *inheritable;
Â Â Â Â Â Â Â Â new->cap_permittedÂ Â Â = *permitted;

Â Â Â Â Â Â Â Â /*
Â Â Â Â Â Â Â Â Â * Mask off ambient bits that are no longer both permitted and
Â Â Â Â Â Â Â Â Â * inheritable.
Â Â Â Â Â Â Â Â Â */
Â Â Â Â Â Â Â Â new->cap_ambient = cap_intersect(new->cap_ambient,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â cap_intersect(*permitted,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â *inheritable));
Â Â Â Â Â Â Â Â if (WARN_ON(!cap_ambient_invariant_ok(new)))
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return -EINVAL;
Â Â Â Â Â Â Â Â return 0;
}
```

å°†cap\_capsetå‡½æ•°å½’çº³ä¸ºå…¬å¼å¦‚ä¸‹ï¼Œè¿›ç¨‹é€šè¿‡capset\(\)è®¾ç½®çš„æ–°çš„æƒé™éœ€è¦æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼Œç¬¦å·\<\< è¡¨ç¤ºå‰è€…æ˜¯åè€…çš„å­é›†ï¼š

```
P'(inheritable) << P(inheritable) | P(permitted)Â  Â //å¦‚æœè®¾ç½®è¿›ç¨‹åœ¨å…¶user nsä¸­ä¸å…·å¤‡CAP_SETPCAPæƒé™ï¼Œåˆ™éœ€æ»¡è¶³è¿™ä¸€ç‚¹,å¦åˆ™ä¸éœ€è¦æ»¡è¶³
P'(inheritable) << P(inheritable) | P(cap_bset)Â 
P'(permitted) << P(permitted)
P'(effective) << P'(permitted)
P'(ambient) = P(ambient) &Â P'(permitted) &Â P'(inheritable)
```

**ä¸‰ã€ä¸åŒå®¹å™¨åœºæ™¯ä¸‹çš„æƒé™**

åœ¨ubuntu 18.04 /linux 4.15å†…æ ¸ä¸Šè§‚å¯Ÿåˆ°çš„æ•°æ®

ç±»å‹1ï¼šæœåŠ¡å™¨ä¸Šå®Œå…¨çœŸrootç”¨æˆ·çš„æƒé™

```
CapInh: 0000000000000000
CapPrm: 0000003fffffffff
CapEff: 0000003fffffffff
CapBnd: 0000003fffffffff
CapAmb: 0000000000000000
```

rootç”¨æˆ·å¯ä»¥é€šè¿‡setuid\(\)ç­‰å‡½æ•°æƒé™é™çº§ï¼Œåˆ°ç±»å‹2ã€‚

ç±»å‹2ï¼šæœåŠ¡å™¨ä¸Šæ™®é€šç”¨æˆ·çš„æƒé™

```
CapInh: 0000000000000000
CapPrm: 0000000000000000
CapEff: 0000000000000000
CapBnd: 0000003fffffffff
CapAmb: 0000000000000000
```

è¿™ç§æ™®é€šç”¨æˆ·æƒé™ï¼Œå¯ä»¥é€šè¿‡è¿è¡Œç±»ä¼¼suå‘½åï¼Œé€šè¿‡setuid\-rootæœºåˆ¶è¿›è¡Œææƒè‡³ç±»å‹1ï¼Œexecææƒè¿‡ç¨‹ä¸­CapBndä¸ºæ»¡æ‰èƒ½ä½¿execåçš„rootå…·å¤‡å®Œæ•´æƒé™ã€‚

ç±»å‹3ï¼šå®¹å™¨å†…ï¼Œä¸å¸¦\-\-privlegedå‚æ•°å¯åŠ¨çš„å®¹å™¨ï¼Œç”¨æˆ·å®é™…ä¸ºroot

```
CapInh: 00000000a80425fb
CapPrm: 00000000a80425fb
CapEff: 00000000a80425fb
CapBnd: 00000000a80425fb
CapAmb: 0000000000000000
```

è¿™ç§ç±»å‹çš„æƒé™ï¼Œç”±äºCapBndéƒ¨åˆ†bitä½æ²¡æœ‰ï¼Œä¸ç®¡æ˜¯é€šè¿‡setuid\(\)ç³»ç»Ÿè°ƒç”¨ï¼Œè¿˜æ˜¯execæœºåˆ¶ï¼Œéƒ½æ— æ³•å®Œæ•´ææƒã€‚

ç±»å‹4ï¼šå®¹å™¨å†…ï¼Œå¸¦\-\-privlegedå‚æ•°å¯åŠ¨çš„å®¹å™¨ï¼Œç”¨æˆ·å®é™…ä¸ºroot

```
CapInh: 0000003fffffffff
CapPrm: 0000003fffffffff
CapEff: 0000003fffffffff
CapBnd: 0000003fffffffff
CapAmb: 0000000000000000
```

**å››ã€å‚è€ƒèµ„æ–™**

1ã€[https://blog.csdn.net/pwl999/article/details/110878563](https://blog.csdn.net/pwl999/article/details/110878563)
