# Linux命令之make

`make`

MAKE

1、makefile组成，三个要素，目标\-依赖\-命令行

```
一个简单的 Makefile 描述规则组成：
TARGET... : PREREQUISITES...
     COMMAND
     ...
```

命令就是在任何一个目标的依赖文件发生变化后重建目标的动作描述。

2、

```
1. 目标文件“edit”不存在，则执行规则以创建目标“edit”。
2. 目标文件“edit”存在，其依赖文件中有一个或者多个文件比它 更新 ， “ ”则根据规则重新链接生成“edit”。
3. 目标文件“edit”存在，它比它的任何一个依赖文件都更新 ， “ ” 则什么也不做。
```

make 本身存在一个默认的规则，能够自动完成对.c 文件的编译并生成对应的.o 文件。它执行命令“cc \-c”来编译.c 源文件。

3、

```
.PHONY : clean
clean :
     -rm edit $(objects)
```

1、通过“.PHONY”特殊目标将“clean”目标声明为伪目标。，避免当磁盘上存在一个名为“clean”文件时，目标“clean”所在规则的命令无法执行

2、在命令行之前使用“\-”，意思是忽略命令“rm”的执行错误。

Makefile 中第一个规则之后的所有以\[Tab\]字符开始的的行，make 程序都会将其交给系统 shell 程序去解释执行。

加\-符号，来忽略此操作的错误

\-include FILENAMES...

反斜杠（\\）是换行符的意思。

makefile中主要包括

```
1、显示规则
2、隐晦规则
3、变量的定义
4、文件的指示
5、注释
```

make工作时执行的步骤

```
1、读入所有的 Makefile。
2、读入被 include 的其它 Makefile。
3、初始化文件中的变量。
4、推导隐晦规则，并分析所有规则。
5、为所有的目标文件创建依赖关系链。
6、根据依赖关系，决定哪些目标要重新生成。
7、执行生成命令。
```

```
PATH = src:../headers
上面的的定义指定两个目录，“src”和“../headers”，make 会按照这个顺序进行搜索。目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方）
另一个设置文件搜索路径的方法是使用 make 的“vpath”关键字（注意，它是全小写的），这不是变量，这是一个 make 的关键字，这和上面提到的那个 VPATH 变量很类似，但是
它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使
用方法有三种：
1、vpath <pattern> <directories>
为符合模式<pattern>的文件指定搜索目录<directories>。
2、vpath <pattern>
清除符合模式<pattern>的文件的搜索目录。
3、vpath
清除所有已被设置好了的文件搜索目录
```

1、大多数的C/C\+\+编译器都支持一个“\-M”的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。如果你使用 GNU 的 C/C\+\+编译器，你得用

“\-MM”参数，不然，“\-M”参数会把一些标准库的头文件也包含进来。

如果 make 执行时，带入 make 参数“\-n”或“\-\-just\-print”，那么其只是显示命令，

但不会执行命令，这个功能很有利于我们调试我们的 Makefile，

makefile中可以出现通配符的场合只有以下两种，变量的定义不能用通配符，只能用wildcard来处理

1. 可以用在规则的目标、依赖中，make 在读取 Makefile 时会自动对其进行匹配处理（通配符展开）；

2. 可出现在规则的命令中，通配符的通配处理是在 shell 在执行此命令时

完成的。

在变量的定义和函数的引用时，通配符将会失效，需要用wildcard

```
#sample Makefile
objects := $(patsubst %.c,%.o,$(wildcard *.c))
foo : $(objects)
     cc -o foo $(objects)
```

make搜索

VPATH  环境变量指定搜索目录

vpath    make的关键字

1、_vpath PATTERN DIRECTORIES_

为所有符合模式“PATTERN”的文件指定搜索目录“DIRECTORIES”。多个目录使用空格或者冒号（：）分开。类似上一小节的“VPATH”变量。

2、_vpath PATTERN_

清除之前为符合模式“PATTERN”的文件设置的搜索路径。

3、_vpath_

清除所有已被设置的文件搜索路径。

vpath %h ../headers

其含义是makefile中出现的.h文件如果不能在当前目录下找到。则到../headers下寻找，但是不能指定c源文件中\#include的头文件，这个需要用gcc  \-I选项。

“$^”代表所有通过目录搜索得到的依赖文件的完整路径名（目录 \+ 一般文件名）列表。

“$@”代表规则的目标。

“$\<”代表规则中通过目录搜索得到的依赖文件列表的第一个依赖文件

"$?" 表示依赖文件列表中被改变过的所有文件

**include**

通常指示符 include”用在以下场合：

1.        有多个不同的程序，由不同目录下的几个独立的 Makefile来描述其重 建规则。它们需要使用一组通用的变量定义或者模式规则。通用的做法是 将这些共同使用的变量或者模式规则定义在一个文件中（没有具体的文 件命名限制），在需要使用的Makefile “ 中使用指示符 include”来包含此 文件。

2.        当根据源文件自动产生依赖文件时；我们可以将自动产生的依赖关系保 存在另外一个文件中，主Makefile “ 使用指示符 include”包含这些文件。 这样的做法比直接在主Makefile中追加依赖文件的方法要明智的多。其 它版本的make已经使用这种方式来处理。

如果 指示符 include”指定的文件不是以斜线开始（绝对路如/usr/src/Makefile...），而且当前目录下也不存在此文件；make将根据文件 “名试 图在以下几个目录下查找：首先，查找使用命令行选项 \-I” “ 或者 \-\-includedir”指定的目录，如果找到指定的文件，则使用这个文件；否则继续依此搜索 “以下几个目录（如果其存在）： /usr/gnu/include” “ 、 /usr/local/include”和 “/usr/include”。

makefile中变量的定义应该放在何处，是否有要求，测试发现变量的定义放在比较后面，可能会没用

makefile中的变量在上一层make file中定义，在下一层makefile中还是有效。反之，下一层makefile定义的变量，上一层不能使用

Makefile:2: \*\*\* commands commence before first target。 停止。

以table开始命令不能放在第一条目标之前

makefile中使用“\-”来忽略错误

makefile可以将makefile文件本身作为目标

在 Makefile中，在第一个规 则之后出现的所有以\[Tab\]字符开始的行都会被当作命令来处理。

Makefile中统配符可以出现 在以下两种场合：

1.        可以用在规则的目标、依赖中，make在读取Makefile时会自动对其进 行匹配处理（通配符展开）；

2.        可出现在规则的命令中，通配符的通配处理是在shell在执行此命令时 完成的。 除这两种情况之外的其它上下文中，不能直接使用通配符。而是需要通过函 “数 wildcard”来实现。  

Makefile中链接静态库和共享库，可以通过共享机制得到，这一特性需要我们在写依赖时，指定一个\-lNAME（）的依赖文件

多目标规则

一个规则中可以有多个目标，规则所定义的命令对所有的目标有效。一个具 有多目标的规则相当于多个规则。规则的命令对不同的目标的执行效果不同，因 “为在 规则的命令中可能使用了自动环变量 $@”。多目标规则意味着所有的目标 具有相同的依赖文件

多规则目标

Makefile中，一个文件可以作为多个规则的目标（多个规则中只能有一个 规则定义命令）。这种情况时，以这个文件为目标的规则的所有依赖文件将会被 合并成此目标一个依赖文件列表，当其中任何一个依赖文件比目标更新（比较 目标文件和依赖文件的时间戳）时，make将会执行特定的命令来重建这个目 标。

静态模式规则（常用）

TARGETS ...: TARGET\-PATTERN: PREREQ\-PATTERNS ...

      COMMANDS ... 

目标：目标模式：依赖模式

     命令

目标模式以目标为基础来匹配，从而生成依赖模式中的文件

例：

objects = foo.o bar.o

all: $\(objects\)

$\(objects\): %.o: %.c

      $\(CC\) \-c $\(CFLAGS\) $\< \-o $@

如果目标和目标模式不匹配，则可以使用filter函数

files = foo.elc bar.o lose.o

$\(filter %.o,$\(files\)\): %.o: %.c

      $\(CC\) \-c $\(CFLAGS\) $\< \-o $@

在变量的定义和函数引用 时，通配符将失效。
